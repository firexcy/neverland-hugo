<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Mac 的内置硬盘「作弊」了吗？ - Neverland</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Note: This article was published as a member-exclusive post for SSPAI Prime, in three installments (part I, II, and III), of which the first was made freely available as a preview and republished here. Please consider subscribing to SSPAI Prime if you find content like this helpful. Thanks for your support. 一 Mac 的固态硬盘性能一直是苹果宣传的重点。特别是近年 Apple T2、M1 等自研芯片整合了主控芯片后，Mac 内" />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="Mac 的内置硬盘「作弊」了吗？" />
<meta property="og:description" content="Note: This article was published as a member-exclusive post for SSPAI Prime, in three installments (part I, II, and III), of which the first was made freely available as a preview and republished here. Please consider subscribing to SSPAI Prime if you find content like this helpful. Thanks for your support. 一 Mac 的固态硬盘性能一直是苹果宣传的重点。特别是近年 Apple T2、M1 等自研芯片整合了主控芯片后，Mac 内" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://type.cyhsu.xyz/unpublished/2022/03/mac-ssd-cheating/" /><meta property="article:section" content="unpublished" />
<meta property="article:published_time" content="2022-03-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-03-11T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Mac 的内置硬盘「作弊」了吗？"/>
<meta name="twitter:description" content="Note: This article was published as a member-exclusive post for SSPAI Prime, in three installments (part I, II, and III), of which the first was made freely available as a preview and republished here. Please consider subscribing to SSPAI Prime if you find content like this helpful. Thanks for your support. 一 Mac 的固态硬盘性能一直是苹果宣传的重点。特别是近年 Apple T2、M1 等自研芯片整合了主控芯片后，Mac 内"/>
<script src="https://type.cyhsu.xyz/js/feather.min.js"></script>
	
	
        <link href="https://type.cyhsu.xyz/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://type.cyhsu.xyz/css/main.8b38b0d7da617241fb660b4f8156d9438a76c98131881f7a02553b711ac2ac70.css" />
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://type.cyhsu.xyz/">Neverland</a>
	</div>
	<nav>
		
		<a href="/colophon/">colophon</a>
		
		<a href="/posts/">archive</a>
		
		<a href="/topics/">topics</a>
		
		<a href="https://platylinks.substack.com">readings</a>
		
		<a href="/feed.xml">rss</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Mac 的内置硬盘「作弊」了吗？</h1>
			<div class="meta">2022-03-11</div>
		</div>
		

		<section class="body">
			<p><strong>Note:</strong> This article was published as a member-exclusive post for <a href="https://sspai.com/prime">SSPAI Prime</a>, in three installments (part <a href="https://sspai.com/prime/story/mac-ssd-cheating-1">I</a>, <a href="https://sspai.com/prime/story/mac-ssd-cheating-2">II</a>, and <a href="https://sspai.com/prime/story/mac-ssd-cheating-3">III</a>), of which the first was made freely available as a preview and republished here. Please consider subscribing to SSPAI Prime if you find content like this helpful. Thanks for your support.</p>
<h2 id="一">一</h2>
<p>Mac 的固态硬盘性能一直是苹果宣传的重点。特别是近年 Apple T2、M1 等自研芯片整合了主控芯片后，Mac 内置固态硬盘相比竞品的性能优势似乎越发明显。在这样的背景下，如果有人站出来说「Mac 的固态硬盘速度有作弊之嫌」，想必会引起不少关注和争议。上个月，这样的讨论确实发生了。</p>
<p>Mac 的固态硬盘性能一直是苹果宣传的重点。特别是近年 Apple T2、M1 等自研芯片整合了主控芯片后，Mac 内置固态硬盘相比竞品的性能优势似乎越发明显。在这样的背景下，如果有人站出来说「Mac 的固态硬盘速度有作弊之嫌」，想必会引起不少关注和争议。</p>
<p><img src="https://cdn.sspai.com/2022/03/11/6a1f576e25db42b637e0d89e5e84adf8.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt=""></p>
<p>Mac 一直致力于宣传内置 SSD 的高性能（来源：苹果）</p>
<p>上个月，这样的讨论确实发生了。</p>
<p>打开话匣的是 <a href="https://twitter.com/marcan42">Hector Martin</a>。先介绍一点背景：此君绝非哗众取宠的无名群众，而是一位资深的信息安全顾问和 Linux 研究者，曾因将 Linux 系统 <a href="https://www.youtube.com/watch?v=QMiubC6LdTA">移植到 PS4 上</a> 而出名。去年以来，Martin 又将目光投向了 <a href="https://asahilinux.org/about/">Asahi Linux</a>，这是一个旨在让 ARM 架构 Mac 运行 Linux 系统的开源项目，目前进展颇多，已接近发布公测版。能主导这样一个高难度项目，Martin 关于 Mac 的观点自然会引起社区的重视。</p>
<p>在 2 月中旬的一串 <a href="https://twitter.com/marcan42/status/1494213855387734019">推文</a> 中，Martin 就提出了一项争议很大的主张：<strong>苹果的定制硬盘确实快得出奇，但却是以牺牲数据一致性（data integrity）为代价的。</strong></p>
<p>这件事的背景是，Martin 在一台 M1 版 MacBook Air 上测试 Linux 系统时，发现很多写入操作慢的出奇，与类似操作在 macOS 下的速度完全不可同日而语。为了找出问题根源，他测试了苹果内置硬盘和其他两款常见固态硬盘的读写性能。</p>
<p>结果非常耐人寻味：</p>
<table>
<thead>
<tr>
<th>硬盘型号</th>
<th>仅写入</th>
<th>写入并冲刷缓冲</th>
</tr>
</thead>
<tbody>
<tr>
<td>内置硬盘</td>
<td>40,000 IOPS</td>
<td>46 IOPS</td>
</tr>
<tr>
<td>西部数据 SN550 NVMe</td>
<td>20,000 IOPS</td>
<td>2,000 IOPS</td>
</tr>
<tr>
<td>三星 860 EVO SATA</td>
<td>5,000 IOPS</td>
<td>143 IOPS</td>
</tr>
</tbody>
</table>
<p>换言之，在「仅写入」的测试中，苹果内置固态硬盘可以达到 4 万次的 IOPS（每秒读写次数），这是主流第三方 NVMe 固态硬盘的 2 倍、SATA 固态硬盘的 8 倍。</p>
<p>但到了「写入并冲刷缓冲」的场景，内置硬盘仅仅取得了 46 IOPS 的「好成绩」，相当于第三方 NVMe 固态硬盘的 2.3%、SATA 固态硬盘的 32.2%，还不如很多机械硬盘。</p>
<p>怎样理解 Martin 前后两次测试的区别和意义呢？</p>
<p>我们知道，<strong>现代计算机中最主要的性能瓶颈就是存储。<strong>因此，软硬件设计中普遍采用</strong>多级缓存</strong>的设计来改善性能。就写入数据这一场景而言，待写入的数据至少要经过系统缓存（OS cache）、磁盘缓冲区（disk buffer）这两道中间环节，才能最终进入永久存储（permanent storage）——机械硬盘的盘片或固态硬盘的闪存颗粒。</p>
<p><img src="https://cdn.sspai.com/2022/03/11/a254575f07cfbaca69d4303e30cdab90.PNG?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt=""></p>
<p>macOS 中的多级缓存（来源：WWDC 2019 演示文稿）</p>
<p>借用送快递来打比方，这就好比一个快件要经过区域分站、小区驿站等中转节点，才能最终送到你手上。</p>
<p>通常情况下，发件方（写入数据的应用程序）并不关心这些底层的区别；它们只是把快件（写入的数据）交给快递公司（操作系统），至于送达方式、成功与否全凭后者的反馈。而为了提高处理效率，操作系统的常见做法是只要快递送到了驿站（数据写进了缓冲区），就反馈说送达成功（写入完成）。至于最后一步「送货上门」（写入永久存储，中文讨论中也常称为「落盘」），则是由操作系统在之后再根据自己的节奏完成——但这已经不受应用程序控制了。</p>
<p>诚然，从日常使用角度而言，前一项数据是用户直接感知的「写入性能」，Mac 内置硬盘也确实有亮眼表现。但一旦发生断电等故障，那些还滞留在驿站的快件（缓冲区未落盘的数据）就有丢失的风险。</p>
<p>此外，快件从驿站派送上门的顺序，往往不同于到达驿站的顺序；派件员（硬盘主控）可能为了省时省事等目的将其重新排列组合。这在平时也无妨，但对于数据库日志、文件系统日志等特殊场合，常常要求关于一项操作的记录必须<strong>先于</strong>这项操作本身落盘（好比从银行存取现金，一定是先记账、再动钱）。这些预写日志（write-ahead log，WAL）会被打上称为「<a href="https://docs.fedoraproject.org//en-US/Fedora/14/html/Storage_Administration_Guide/writebarr.html">写入屏障</a>」（write barrier）的标签，享受「优先派送」的待遇，它的落盘效率直接影响到后续操作何时能进行。</p>
<p>因此，如果说 Martin 测试的前一项数据代表了数据<strong>日常写入</strong>的效率，那么后一项数据则代表了数据<strong>落袋为安</strong>的效率，同样不能忽视。而正是在这项性能上，Mac 发生了翻车。</p>
<p>不仅如此，Martin 还宣称<strong>发现了 macOS 的一项「作弊」行为。</strong></p>
<p>在测试落盘性能时，他最初使用了 <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> 标准定义的 <code>fsync()</code> 系统调用。POSIX 是一套旨在促进操作系统相互兼容的接口标准，Linux 是在 POSIX 标准的指导下开发的（尽管并未完全遵循），而 macOS 更是通过了其 <a href="https://www.opengroup.org/openbrand/register/apple.htm">认证</a>。因此按理说，两个系统执行 <code>fsync()</code> 的结果应该是一致的，也就是像标准所 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html">规定</a> 的那样，「强制对缓冲中的数据执行物理写入，并确保系统崩溃等错误后，截至调用前的所有数据均已录入磁盘」。</p>
<p>实际情况并非如此。Martin 发现，Linux 的确执行了 <code>fsync()</code> 所附加的冲刷缓冲动作，测出的写入效率也比不冲刷缓冲时相应降低。但如果在一台 MacBook Air 上用 <code>fsync()</code> 写入数据，五秒之后通过 PD 协议发去一条强制重启指令，这些理论上应该落盘的数据还是会丢失。他又换了一台 Mac mini，用 <code>fsync()</code> 写入数据五秒之后直接拔了插头，同样出现了丢数据的情况。</p>
<p>这种现象只有一种可能原因，那就是 <strong>macOS「无视」了</strong> <code>**fsync()**</code> <strong>所附加的落盘要求。</strong></p>
<p>的确，如果你在 macOS 下查阅 <code>fsync()</code> 的手册页面（可以在终端执行 <code>man fsync</code> 查阅）中，就能看到这样一段说明：</p>
<blockquote>
<p>注意，尽管 <code>fsync()</code> 将所有数据从宿主冲刷到驱动器（即「永久存储设备」），该驱动器自身可能<strong>在相当长的时间内都并不会将数据在物理意义上写入盘片</strong>，并且可能不依先后顺序写入。具体而言，如果驱动器断电、操作系统崩溃，应用程序的数据<strong>可能只被部分写入，或完全没有写入</strong>。磁盘还可能重新排序数据，导致<strong>后来的写入还存在，而早先的写入则丢失。</strong><br>
这并不只是理论上的罕见场景，而是很容易在现实工作的负荷或驱动器断电故障中复现。<br>
对于要求保证更高数据完整性的应用程序，Mac OS X 提供了 <code>F_FULLFSYNC</code> 这一 <code>fcntl</code> 命令。<code>F_FULLFSYNC</code> 要求驱动器冲刷所有缓冲区数据，写入永久存储。<br>
[ 节选翻译；粗体均为笔者所加 ]</p>
</blockquote>
<p>换言之，在 macOS 下， <code>fsync()</code> 并不会冲刷缓冲区。要实现与 Linux 下相同的效果，应该使用另一个函数 <code>fcntl()</code>，并附加 <code>F_FULLFSYNC</code> 作为命令参数。</p>
<p>事实上，促使 Martin 开展这项测试的疑问——内置硬盘在 macOS 和 Linux 下性能差距巨大，其原因正在于此。如果对于同一项操作，Linux 因为 <code>fsync()</code> 的要求「送货上门」，而 macOS 却耍滑头地送到驿站就点了送达，那么两者的效率当然不能同日而语。</p>
<p>Martin 由此得出的观点是：如果一直「岁月静好」，Mac 内置硬盘确实速度令人望其项背。但一旦发生断电的意外事故，它就比第三方硬盘有更大风险遭遇数据丢失，对于没有电池作为后备供电的桌面型 Mac 就更是如此。</p>
<p>显然，Martin 的观点不可能不在社区引起热议。截至本文写作时，他的推文已经获得了近 1800 次转发，5900 多次点赞；在 <a href="https://news.ycombinator.com/item?id=30370551">Hacker News</a> 和 <a href="https://old.reddit.com/r/apple/comments/sun6pa/apples_custom_nvme_drives_are_amazingly_fast_if/">Reddit</a> 上的讨论帖也堆到了数百层高。这些讨论中，社区用户从不同角度对 Martin 提出了补充和质疑观点。</p>
<hr>
<p>那么，Martin 说得有道理吗？与 Linux 相比，macOS 真的是一个不那么负责任的「快递公司」吗？这将是本文 <a href="https://sspai.com/prime/story/mac-ssd-cheating-2">下一部分</a> 的主题。<strong>[ 待续 ]</strong></p>
<h2 id="二">二</h2>
<p><a href="https://sspai.com/prime/story/mac-ssd-cheating-1">前文</a> 提到，Martin 关于 Mac 内置硬盘的测试在社区引起了热议。讨论过程中，最突出的争议焦点是 Martin 用「作弊」一词来形容 macOS。对此，不少观点认为这种说法并不准确。他们的主要理由有两点。</p>
<hr>
<h3 id="macos-没有刻意误导">macOS 没有刻意误导</h3>
<p>首先，<strong>苹果并没有刻意隐藏或误导</strong> <code>**fsync()**</code> <strong>在 macOS 下的不同行为</strong>。相反，苹果还通过文档和讲座，反复解释和说明这一区别，以及背后的设计逻辑。</p>
<p>例如，上文引述的 <code>fsync()</code> 手册页面就是一例。此外，在 XNU（macOS 的内核）的 <a href="https://github.com/apple/darwin-xnu/blob/main/bsd/sys/fcntl.h">源代码</a> 中，也可以看到苹果的注释说明：<code>F_FULLFSYNC</code> 相当于执行 <code>fsync()</code> 并冲刷缓冲区（第 279 行）。</p>
<p>实际上，<code>**fsync()**</code> **在 macOS 和 Linux 上的差异并不是一直存在的。**正如推特用户 Dominic Evans <a href="https://twitter.com/oldmanuk/status/1494246227667468289">指出</a>，早期版本的 Linux 内核和 OS X（macOS 的曾用名）一样，也不会在执行 <code>fsync()</code> 时冲刷缓冲区。只是到了 2.6 版的若干小版本更新中，Linux 才修改了 <code>fsync()</code> 的行为，使其具有了冲刷缓冲的额外效果。</p>
<p>从 Linux 版 <code>fsync()</code> 的手册页面 <a href="https://man7.org/linux/man-pages/changelog.html#release_2.31">修订历史</a> 也可以看出这一点。早期版本的手册还表示「如果硬盘启用了写入缓冲，数据可能并未实际写入永久存储」；晚近版本中，这样的表述已经被「<code>fsync()</code> 包括冲刷既存缓冲」取代了。</p>
<p><strong>这个问题也远非被第一次提出。</strong> 早在 2005 年，资深苹果工程师 Dominic Giampaolo 就在一次邮件列表回复中 <a href="https://lists.apple.com/archives/darwin-dev/2005/Feb/msg00087.html">解释</a> 过这个问题。当时，MySQL 数据库在一次更新日志中称，其在 Mac 平台上用 <code>fcntl()</code> 代替了 <code>fsync()</code>，因为苹果在内置硬盘上「禁用」了 <code>fsync()</code> [ 的冲刷缓冲功能 ]。</p>
<p>Giampaolo 反驳了这一表述，指出 <code>fsync()</code> 在 OS X 和其他 Unix 家族的系统上从来就没有保证过落盘。正是因为考虑到有此需求，苹果才专门增加了 <code>F_FULLFSYNC()</code> 参数用来提供这一选项。由于这将是一项影响性能的「重度」操作，只应该在数据库之类需要确保数据一致性的场景下使用；而对于大多数日常操作，<code>fsync()</code> 就足够了。</p>
<p>此后，苹果还在多个官方渠道传递过类似信息，包括官网一篇题为 <a href="https://developer.apple.com/documentation/xcode/reducing-disk-writes">《减少磁盘写入》</a> 的开发者文档，以及 2019 年的 WWDC 上一场「在你的应用中优化存储」（<a href="https://developer.apple.com/videos/play/wwdc2019/419">Optimizing Storage in Your App</a>）讲座等。</p>
<p><img src="https://cdn.sspai.com/2022/03/11/7e57df8cfcf3a42a68e58e968fa6be4d.PNG?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt=""></p>
<p>苹果工程师在 WWDC 2019 讲座上对 fync() 的介绍（来源：WWDC 2019 演示文稿）</p>
<p>换言之，至少在苹果看来，他们的设计并没有忽略落盘这一需求，相反是给开发者<strong>提供了更加灵活的选择</strong>，即根据不同应用场景在性能和数据安全之间做出不同权衡。</p>
<h3 id="第三方硬盘可能没说实话">第三方硬盘可能没说实话</h3>
<p>其次，所谓「一个巴掌拍不响」，数据写入是一项需要软硬件相互配合的操作。<strong>操作系统如何指令是一回事，硬盘的主控及其固件如何响应这些指令则是另一回事。</strong></p>
<p>如果操作系统在执行 <code>fsync()</code> （或 macOS 上的 <code>F_FULLFSYNC</code>）下达了确保数据落盘的指令，如果硬盘「执行不力」，一俟数据写入缓冲区，就敷衍反馈任务完成了，操作系统其实也无从核实。</p>
<p>**这并非只是理论上可能出现的情况。**好巧不巧，就在 Martin 引起的讨论余波未尽时，苹果工程师 Russ Bishop 在推特上表示，自己 <a href="https://twitter.com/xenadu02/status/1495693475584557056">测试了</a> 一系列不同品牌的固态硬盘，发现它们对于断电事故的防护能力各不相同。</p>
<p>其中，三星、西部数据、英特尔、希捷、英睿达（Crucial）的受测型号经受住了考验，而海力士（SK Hynix）和 Sabrent 的两种型号则在断电后发生了丢数据的情况。</p>
<p>值得注意的是，Bishop 正是<strong>通过 macOS 的</strong> <code>**F_FULLFSYNC**</code> <strong>功能来写入测试数据的</strong>。如上文所述，这个指令会要求硬盘冲刷缓冲区。如果在执行过后仍然发生丢数据的情况，<strong>「责任」只可能在于硬盘身上</strong>——它没有遵照操作系统的命令以及 NVMe 的 <a href="https://nvmexpress.org/wp-content/uploads/NVM-Express-Base-Specification-2.0b-2021.12.18-Ratified.pdf">技术规范</a>（PDF），将数据提交至非易失媒介（non-volatile media），也就是存储颗粒上（§7.1, revision 2.0b）。</p>
<p>Bishop 显然不是第一个发现这个问题的人。2011 年，威斯康星大学麦迪逊分校的几名研究者就在提交给 IEEE 国际会议的一篇 <a href="https://ieeexplore.ieee.org/document/5958264">论文</a> 中详细讨论过这种现象，称之为将性能放在稳定性之上的营销逐利行为。</p>
<p>推特上，参与过往年 macOS 开发的 <a href="https://twitter.com/rosyna/status/1494248499067514883">Rosyna Keller</a>、<a href="https://twitter.com/wooster/status/1494253898026029057">Andrew Wooster</a> 等人也结合实际经历 <a href="https://twitter.com/rosyna/status/1494248499067514883">指出</a>，忽略冲刷缓冲区的要求、对操作系统撒谎是第三方硬盘曝片存在的现象，曾给苹果团队开发 Time Machine 备份等功能造成过很大的困扰；反倒是 Mac 的内置硬盘始终保持「诚实」。</p>
<p>而苹果之所以没有「从善如流」，学习 Linux 修改 <code>fsync()</code> 的行为，除了是因为已经有了等效的 <code>F_FULLFSYNC</code> 选项，另一个考虑也是和已经染上不靠谱名声的 <code>fsync()</code> 区分开，给开发者更清晰的选择。</p>
<hr>
<p>讨论至此，我们似乎还忽略了另外一个重要阵营——Windows 系统下的情况。我们将在本文的 <a href="https://sspai.com/prime/story/mac-ssd-cheating-3">最后一部分</a> 来看看这块「他山之石」。<strong>[ 待续 ]</strong></p>
<h2 id="三">三</h2>
<p>前文中，我们介绍了社区对 Martin 所做测试和主张的不同意见。本文中，我们将暂时跳出 Unix 一脉系统，看看另一个阵营的 Windows 系统是如何处理硬盘缓冲的。最后，我们将讨论对于普通用户来说，可以从此事及其相关讨论中得到的启示。</p>
<p><a href="https://sspai.com/prime/story/mac-ssd-cheating-2">前文</a> 中，我们介绍了社区对 Martin 所做测试和主张的不同意见。下面，我们将暂时跳出 Unix 一脉系统，看看另一个阵营的 Windows 系统是如何处理硬盘缓冲的。</p>
<hr>
<h3 id="他山之石windows-下的硬盘缓冲">他山之石——Windows 下的硬盘缓冲</h3>
<p>Windows 没有 Unix 基因，不存在怎样实现 <code>fsync()</code> 的问题，但仍然免不了考虑「把数据扔给硬盘」和「盯着硬盘完成写入」的区分。</p>
<p>对此，Win32 API 分别提供了 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile"><code>WriteFile</code></a> 和 <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-flushfilebuffers"><code>FlushFileBuffers</code></a> 这两个函数；使用后者写入文件，其效果就类似于在 Linux 上执行 <code>fsync()</code> 或在 macOS 上执行 <code>F_FULLFSYNC</code>——在写入文件的同时刷新缓冲区、并将所有缓冲数据落盘。</p>
<p>此外，Windows 还在用户界面上提供了与硬盘缓冲相关的选项。在开始菜单的搜索框输入 <code>devmgmt.msc</code> 并回车（或者在「开始」按钮上点击右键），打开「设备管理器」；然后，在硬盘名称上点击右键，选择「属性」，切换到「策略」选项卡。</p>
<p><img src="https://cdn.sspai.com/2022/03/11/9a62a08c96c2d702038c085510d11512.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt=""></p>
<p>这里，「写入缓存策略」部分的两个复选框就是用来控制缓冲区开关和行为的。其中，「启用设备上的写入缓存」是一个整体开关，只有将其勾选，Windows 才会在这块硬盘上使用缓冲区；否则，Windows 会试图让每次写入都直接落盘（Windows 10 1809 版起，这 <a href="https://docs.microsoft.com/en-US/windows/client-management/change-default-removal-policy-external-storage-media">成为了</a> U 盘等外置存储的默认行为）。</p>
<p>但正如微软自己在这个选项旁边提示的，「停电或设备故障可能会导致数据丢失或损坏」。为了降低这一风险，Windows 提供了一项预防机制，即此处第二个选项中提到的「写入高速缓存缓冲区刷新」。这是指 Windows 会不时要求硬盘冲刷缓冲区，类似于在 Linux 上隔一段时间就调用一次 <code>fsync()</code>。</p>
<p>缓冲区刷新是默认开启的，但可以通过手动勾选复选框来关闭。从界面描述看，微软显然并不希望你这么做：「为了防止数据丢失，如果设备没有单独的电源以允许该设备在电源故障时刷新其缓冲区，请勿选中此复选框」（实际上，这句提示随着 Windows 的演进还在 <a href="https://devblogs.microsoft.com/oldnewthing/20130416-00/?p=4643">变得越来越严厉</a>）。</p>
<p>然而，如果你在网上搜索这两个选项，能看到大量说法相左的「经验」「技巧」，内容大致都是惊叹自己在勾选（或不勾选）后观察到了翻天覆地的性能提升，给出的理由也是五花八门。</p>
<p>不仅如此，这个选项可能<strong>根本没有什么实际意义</strong>。微软首席工程师 Raymond Chen 曾在 2007 年的 <em>TechNet</em> 杂志上 <a href="https://docs.microsoft.com/en-us/previous-versions/technet-magazine/cc162475(v=msdn.10)">撰文</a> 回忆到，Windows 3.11 版本曾经存在一个 bug，导致系统经常忽视应用程序提出的冲刷缓冲区的请求。这被当时的一些开发商误解为真实的性能优化，本着「不用白不用」的心态，在软件中到处滥用冲刷指令，连鼠标和键盘操作后都要「冲刷」一下。</p>
<p>随着 Windows 95 修复了这个漏洞，冲刷指令的性能影响重新体现出来，那些第三方软件的体验则受到了毁灭性打击。在大量投诉下，微软出于妥协才加入了这个旨在让修好的 bug「复活」的选项。（还有说法 <a href="https://forums.anandtech.com/threads/write-cache-buffer-flushing-too-dangerous-to-disable.2363132/post-35937194">称</a>，这些厂商在不满之下反咬一口，状告微软是出于「垄断」目的才做的这一修改。）</p>
<p><img src="https://cdn.sspai.com/2022/03/11/article/dabc2202c46c8a32267f52e8383d7c6b?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt="Figure 1 Enabling buggy behavior in Windows Server 2003"></p>
<p>Windows 2003 中的磁盘属性设置，「禁用缓冲区刷新」被美其名曰「启用高性能模式」，其实是指「启用 bug 模式」（来源：微软 MSDN）</p>
<p>这固然是一个戏剧化的轶闻，但也在一定程度上表明了 Windows 的特征：由于平台<strong>高度异质化、历史包袱颇多</strong>，很多功能开关最多只能起到「尽力而为」的作用。具体到「缓冲区刷新」这个选项，由于厂商完全可能通过固件和驱动对这些选项做出不同响应，其具体效果必然高度依赖于硬盘的颗粒、主控，使用的驱动程序及其版本。</p>
<p>因此，对于用户而言，如果没有特别的理由，<strong>最理性的选择就是保持默认设置不动</strong>，以及遵循厂商的建议（例如，<a href="https://www.intel.com/content/www/us/en/support/articles/000006457/memory-and-storage.html">英特尔</a> 和 <a href="https://semiconductor.samsung.com/consumer-storage/support/faqs/03/">三星</a> 都建议对于消费级产品开启写入缓存）。</p>
<h3 id="结论">结论</h3>
<p>总结起来，抛开「作弊」这种过于主观、容易引战的表述，对现状比较公允的表述可能是：</p>
<ul>
<li>因为一些<strong>历史而非刻意的</strong>原因，macOS 采用了与 Linux 不同的方式提供数据写入接口，但<strong>后果优劣则因人而异</strong>，跨平台开发者比原生应用开发者更容易因此产生困惑。</li>
<li>就<strong>冲刷缓冲</strong>这项操作而言，Mac 内置硬盘的缺点是效率不及主流第三方产品（且原因暂时不明）；但优点是得益于与 macOS 的垂直整合，只要程序提出要求就可以确保数据落盘，不用担心像一些第三方硬盘那样另有算盘。</li>
</ul>
<p>诚然，这些技术上的细节更多应交给厂商和开发者来关心。但对于普通用户来说，也可以从此事及其相关讨论中得到不少有价值的启示。</p>
<p>首先，<strong>任何跑分测试的结果都是相对的</strong>。</p>
<p>现代的存储设备和相关的存储机制早已被高度抽象化了；软件层面的概念和硬件层面的部件很少是一一对应的。尽管上文反复提及「系统缓存」「硬盘缓冲」等概念，但它们并没有表面上那样泾渭分明。</p>
<p>一方面，如果启用了虚拟内存，系统缓存的职能可能分配给硬盘来执行；另一方面，随着无板载 DRAM 的流行，很多固态硬盘又会反过来征用主内存作为缓冲区（典型例子包括 NVMe 标准中的 <a href="https://nvmexpress.org/faq-items/what-is-a-host-memory-buffer/">HMB</a>、英睿达 <a href="https://www.crucial.cn/support/articles-faq-ssd/overview-crucial-storage-executive">Executive 驱动</a> 的 Momentum Cache、三星 <a href="https://semiconductor.samsung.com/resources/software-resources/Samsung_Magician_7_0_1_Installation_Guide_v1.1.pdf">Magician 驱动</a> 的 <a href="https://semiconductor.samsung.com/resources/white-paper/Samsung_SSD_Rapid_Mode_Whitepaper_EN.pdf">RAPID Mode</a> 等）。即使到了硬盘内部，普遍存在的「SLC 缓存」（在廉价的 TLC 或 QLC 硬盘中，将多个颗粒「合并」模拟成高速的 SLC 颗粒）也会进一步构造出性能台阶。</p>
<p><img src="https://cdn.sspai.com/2022/03/11/64427bd15c9f1909138dd4c1c1d8bafe.png?imageView2/2/w/1120/q/40/interlace/1/ignore-error/1" alt=""></p>
<p>三星 Magician 驱动程序提供的 RAPID 功能（来源：三星）</p>
<p>如果在测试中未能控制这些变量中的任何一个，都会产生有偏差的结果。换个角度说，任何测试结果也只有结合特定测试条件、具体使用场景理解才有意义。</p>
<p>其次，<strong>不存在什么绝对的标准和原则</strong>。</p>
<p>在本次事件的讨论中，可以观察到一个问题反复出现：POSIX 标准对 <code>fsync()</code> 的定义，以及 NVMe 标准对冲刷指令的定义，究竟是<strong>过程导向</strong>（把数据传给硬盘）的还是<strong>结果导向</strong>（保证数据落盘）的？对这个问题的不同回答会导致对各家设计的不同评价。</p>
<p>但实际上，这两份标准本身也给留出了很多例外情况和裁量空间。POSIX 标准指出，如果使用环境不要求同步写入（即不需要在写入数据的同时保证落盘），那么系统对 <code>fsync()</code> 的效果可以高度自主，哪怕「啥都不干」（a null implementation）也是可以的；NVMe 标准也提到，如果主控能保证即使断电不会丢数据（例如自带了电池、电容等防断电机制的硬盘），那么只是进入 DRAM 的数据也可以视为「非易失」的。</p>
<p>换言之，场景比教条更重要。存储相关软硬件设计的评判标准不仅是看哪个<strong>更遵守标准</strong>，更主要是看哪个在性能和稳定性找到了<strong>更好的平衡</strong>。</p>
<p>最后，<strong>计算机部件的集成化是一把双刃剑。</strong></p>
<p>放在十几年前，很难想象硬盘这种「笨」设备可以搭载一块性能堪比早期主机的主控芯片，无需主机介入就能独立承担缓存控制、垃圾收集等职能。但高度的集成化也会导致高度的不透明，操作系统越发对硬件的行为失去控制，用户也越发难以在出现问题时自主排查和修复。</p>
<p>但越是如此，那些老生常谈的经验就越是适用：做好数据备份；台式机应考虑添置后备电源；驱动安装和配置调节以官方口径为准，不要不明原理而听信一些「江湖偏方」。<strong>[ 全文完 ]</strong></p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/macos">macOS</a></li>
					
					<li><a href="/tags/explainer">explainer</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
<hr>

2022  © Platy Hsu |  Built with <a href="https://gohugo.io">Hugo</a>
</footer>


</div>
    </body>
</html>
